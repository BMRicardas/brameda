name: Deploy Website

on:
  # Contentful webhook trigger
  repository_dispatch:
    types: [contentful-publish]

  # Main branch trigger
  push:
    branches: [main]

  # Manual trigger
  workflow_dispatch:

env:
  NODE_VERSION: 20
  MAX_BACKUPS: 5

jobs:
  verify-webhook:
    runs-on: ubuntu-latest
    if: github.event_name == 'repository_dispatch'
    outputs:
      webhook-verified: ${{ steps.verify.outputs.verified }}
    steps:
      - name: Verify Contentful webhook
        id: verify
        env:
          WEBHOOK_SECRET: ${{ secrets.CONTENTFUL_WEBHOOK_SECRET }}
        run: |
          PAYLOAD='${{ toJSON(github.event.client_payload) }}'
          [ -z "$PAYLOAD" ] || [ "$PAYLOAD" = "null" ] && PAYLOAD='{}'

          # Extract signature from multiple possible locations
          SIGNATURE=$(echo "$PAYLOAD" | jq -r '
            .signature // 
            .secret // 
            .headers["x-contentful-webhook-signature"] // 
            .headers["X-Contentful-Webhook-Signature"] // 
            empty
          ')

          # Mask sensitive values
          echo "::add-mask::$WEBHOOK_SECRET"
          [ -n "$SIGNATURE" ] && echo "::add-mask::$SIGNATURE"

          # Validate signature
          if [ -z "$SIGNATURE" ]; then
            echo "‚ùå No webhook signature found"
            echo "Available keys: $(echo "$PAYLOAD" | jq -r 'keys | join(", ")')"
            exit 1
          fi

          if [ "$SIGNATURE" != "$WEBHOOK_SECRET" ]; then
            echo "‚ùå Webhook signature verification failed"
            exit 1
          fi

          echo "‚úÖ Webhook verified successfully"
          echo "verified=true" >> $GITHUB_OUTPUT

  build:
    runs-on: ubuntu-latest
    needs: [verify-webhook]
    if: always() && (github.event_name != 'repository_dispatch' || needs.verify-webhook.outputs.webhook-verified == 'true')
    outputs:
      deployment-message: ${{ steps.vars.outputs.message }}
      timestamp: ${{ steps.vars.outputs.timestamp }}
      backup-dir: ${{ steps.vars.outputs.backup_dir }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: npm

      - name: Install dependencies
        run: npm ci

      - name: Set deployment variables
        id: vars
        run: |
          if [ "${{ github.event_name }}" = "repository_dispatch" ]; then
            echo "message=üöÄ Deploying from Contentful update" >> $GITHUB_OUTPUT
          else
            echo "message=üöÄ Deploying from main branch update" >> $GITHUB_OUTPUT
          fi
          echo "timestamp=$(date +%Y%m%d_%H%M%S)" >> $GITHUB_OUTPUT
          echo "backup_dir=$(dirname ${{ secrets.FTP_PUBLIC_DIR }})/backups" >> $GITHUB_OUTPUT

      - name: Build Astro site
        run: npm run build
        env:
          CONTENTFUL_SPACE_ID: ${{ secrets.CONTENTFUL_SPACE_ID }}
          CONTENTFUL_DELIVERY_TOKEN: ${{ secrets.CONTENTFUL_DELIVERY_TOKEN }}
          CONTENTFUL_PREVIEW_TOKEN: ${{ secrets.CONTENTFUL_PREVIEW_TOKEN }}
          WEB3FORMS_PUBLIC_ACCESS_KEY: ${{ secrets.WEB3FORMS_PUBLIC_ACCESS_KEY }}

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: dist-${{ steps.vars.outputs.timestamp }}
          path: dist/
          retention-days: 7

  deploy:
    runs-on: ubuntu-latest
    needs: [build]
    environment: production
    steps:
      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: dist-${{ needs.build.outputs.timestamp }}
          path: dist/

      - name: Manage backups and deploy
        env:
          FTP_SERVER: ${{ secrets.FTP_SERVER }}
          FTP_USERNAME: ${{ secrets.FTP_USERNAME }}
          FTP_PASSWORD: ${{ secrets.FTP_PASSWORD }}
          FTP_PUBLIC_DIR: ${{ secrets.FTP_PUBLIC_DIR }}
          BACKUP_DIR: ${{ needs.build.outputs.backup-dir }}
          TIMESTAMP: ${{ needs.build.outputs.timestamp }}
        run: |
          # Install lftp for advanced FTP operations
          sudo apt-get update && sudo apt-get install -y lftp

          # Create backup management script
          cat > backup_and_deploy.sh << 'EOF'
          #!/bin/bash
          set -e

          echo "üîß Connecting to FTP server..."

          lftp -c "
            set ssl:verify-certificate false
            set ftp:ssl-allow false
            open -u $FTP_USERNAME,$FTP_PASSWORD $FTP_SERVER
            
            echo 'üìã Listing existing backups...'
            mkdir -p $BACKUP_DIR
            cd $BACKUP_DIR
            
            # Get list of backup directories, sorted by name (which includes timestamp)
            cls -1 backup_* | sort > /tmp/backups.txt || echo 'No existing backups found'
            
            # Count existing backups
            BACKUP_COUNT=\$(wc -l < /tmp/backups.txt 2>/dev/null || echo 0)
            echo \"Found \$BACKUP_COUNT existing backups\"
            
            # Remove old backups if we have more than MAX_BACKUPS-1 (to make room for new one)
            if [ \$BACKUP_COUNT -ge $MAX_BACKUPS ]; then
              BACKUPS_TO_DELETE=\$((BACKUP_COUNT - $MAX_BACKUPS + 1))
              echo \"üóëÔ∏è Removing \$BACKUPS_TO_DELETE old backup(s)...\"
              head -n \$BACKUPS_TO_DELETE /tmp/backups.txt | while read backup; do
                echo \"Removing: \$backup\"
                rm -rf \$backup
              done
            fi
            
            echo 'üì¶ Creating backup of current deployment...'
            mkdir -p backup_$TIMESTAMP
            mirror -R $FTP_PUBLIC_DIR backup_$TIMESTAMP
            
            echo 'üöÄ Deploying new version...'
            mirror -eRv dist/ $FTP_PUBLIC_DIR --ignore-time --exclude .git --exclude node_modules --exclude wp --exclude .well-known
            
            echo '‚úÖ Deployment completed successfully'
            
            quit
          "
          EOF

          chmod +x backup_and_deploy.sh
          ./backup_and_deploy.sh

      - name: Verify deployment
        env:
          DEPLOYMENT_URL: ${{ secrets.DEPLOYMENT_URL }}
        run: |
          if [ -n "${DEPLOYMENT_URL:-}" ]; then
            echo "üîç Verifying deployment at $DEPLOYMENT_URL"
            # Simple HTTP check
            if curl -f -s -o /dev/null "$DEPLOYMENT_URL"; then
              echo "‚úÖ Deployment verification successful"
            else
              echo "‚ùå Deployment verification failed"
              exit 1
            fi
          else
            echo "‚ÑπÔ∏è No DEPLOYMENT_URL configured, skipping verification"
          fi

      - name: Rollback on failure
        if: failure()
        run: |
          echo "‚ùå Deployment failed"
          echo "üí° Consider implementing a rollback strategy:"
          echo "   1. Keep previous build artifacts"
          echo "   2. Use FTP snapshots if available"
          echo "   3. Implement database backups if needed"
          echo "   4. Set up monitoring and alerts"

  notify:
    runs-on: ubuntu-latest
    needs: [build, deploy]
    if: always()
    steps:
      - name: Notify deployment status
        run: |
          if [ "${{ needs.deploy.result }}" = "success" ]; then
            echo "üéâ ${{ needs.build.outputs.deployment-message }} - SUCCESS"
          else
            echo "üí• Deployment failed - check logs for details"
          fi
