name: Deploy Website

on:
  repository_dispatch:
    types: [contentful-publish]
  push:
    branches: [main]
  workflow_dispatch:

env:
  NODE_VERSION: "20.x"
  MAX_BACKUPS: 5

jobs:
  verify-webhook:
    runs-on: ubuntu-latest
    if: github.event_name == 'repository_dispatch'
    outputs:
      webhook-verified: ${{ steps.verify.outputs.verified }}
    steps:
      - name: Verify Contentful webhook
        id: verify
        env:
          WEBHOOK_SECRET: ${{ secrets.CONTENTFUL_WEBHOOK_SECRET }}
        run: |
          # Get the payload and signature from Contentful webhook
          PAYLOAD='${{ toJSON(github.event.client_payload) }}'
          [ -z "$PAYLOAD" ] || [ "$PAYLOAD" = "null" ] && PAYLOAD='{}'

          # Extract the signature from the payload
          RECEIVED_SIGNATURE=$(echo "$PAYLOAD" | jq -r '.signature // empty')
          TIMESTAMP=$(echo "$PAYLOAD" | jq -r '.timestamp // empty')
          BODY=$(echo "$PAYLOAD" | jq -r '.body // "{}"')

          # Mask sensitive values
          echo "::add-mask::$WEBHOOK_SECRET"
          [ -n "$RECEIVED_SIGNATURE" ] && echo "::add-mask::$RECEIVED_SIGNATURE"

          # Verify we have required data
          if [ -z "$RECEIVED_SIGNATURE" ] || [ -z "$TIMESTAMP" ]; then
            echo "‚ùå Missing required webhook data (signature or timestamp)"
            echo "Available keys: $(echo "$PAYLOAD" | jq -r 'keys | join(", ")')"
            exit 1
          fi

          # Create the expected signature (HMAC-SHA256)
          EXPECTED_SIGNATURE=$(echo -n "${TIMESTAMP}${BODY}" | openssl dgst -sha256 -hmac "$WEBHOOK_SECRET" | sed 's/^.* //')

          # Verify signatures match
          if [ "$RECEIVED_SIGNATURE" != "$EXPECTED_SIGNATURE" ]; then
            echo "‚ùå Webhook signature verification failed"
            exit 1
          fi

          # Check timestamp is recent (within 5 minutes)
          CURRENT_TIME=$(date +%s)
          TIME_DIFF=$((CURRENT_TIME - TIMESTAMP))
          if [ $TIME_DIFF -gt 300 ]; then
            echo "‚ùå Webhook timestamp too old (${TIME_DIFF}s ago)"
            exit 1
          fi

          echo "‚úÖ Webhook verified successfully"
          echo "verified=true" >> $GITHUB_OUTPUT

  build:
    runs-on: ubuntu-latest
    needs: [verify-webhook]
    if: always() && (github.event_name != 'repository_dispatch' || needs.verify-webhook.outputs.webhook-verified == 'true')
    outputs:
      deployment-message: ${{ steps.vars.outputs.message }}
      timestamp: ${{ steps.vars.outputs.timestamp }}
      artifact-name: ${{ steps.vars.outputs.artifact_name }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: npm

      - name: Install dependencies
        run: npm ci

      - name: Set deployment variables
        id: vars
        run: |
          TIMESTAMP=$(date +%Y%m%d_%H%M%S)
          ARTIFACT_NAME="dist-${TIMESTAMP}"

          if [ "${{ github.event_name }}" = "repository_dispatch" ]; then
            MESSAGE="üöÄ Deploying from Contentful update"
          else
            MESSAGE="üöÄ Deploying from main branch update"
          fi

          echo "message=${MESSAGE}" >> $GITHUB_OUTPUT
          echo "timestamp=${TIMESTAMP}" >> $GITHUB_OUTPUT
          echo "artifact_name=${ARTIFACT_NAME}" >> $GITHUB_OUTPUT

      - name: Build Astro site
        run: npm run build
        env:
          CONTENTFUL_SPACE_ID: ${{ secrets.CONTENTFUL_SPACE_ID }}
          CONTENTFUL_DELIVERY_TOKEN: ${{ secrets.CONTENTFUL_DELIVERY_TOKEN }}
          CONTENTFUL_PREVIEW_TOKEN: ${{ secrets.CONTENTFUL_PREVIEW_TOKEN }}
          WEB3FORMS_PUBLIC_ACCESS_KEY: ${{ secrets.WEB3FORMS_PUBLIC_ACCESS_KEY }}

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.vars.outputs.artifact_name }}
          path: dist/
          retention-days: 30

  deploy:
    runs-on: ubuntu-latest
    needs: [build]
    environment: production
    steps:
      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: ${{ needs.build.outputs.artifact-name }}
          path: dist/

      - name: Create deployment scripts
        run: |
          # Create backup management script
          cat > backup_manager.sh << 'EOF'
          #!/bin/bash
          set -e

          SFTP_HOST="$1"
          SFTP_USER="$2"
          REMOTE_DIR="$3"
          BACKUP_DIR="$4"
          TIMESTAMP="$5"
          MAX_BACKUPS="$6"

          echo "üì¶ Creating backup of current deployment..."

          # Create backup directory locally
          mkdir -p "backup_${TIMESTAMP}"

          # Download current deployment for backup
          sftp -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null "$SFTP_USER@$SFTP_HOST" << SFTP_EOF
          get -r $REMOTE_DIR/* backup_${TIMESTAMP}/
          quit
          SFTP_EOF

          # Upload backup to backup directory
          sftp -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null "$SFTP_USER@$SFTP_HOST" << SFTP_EOF
          -mkdir $BACKUP_DIR
          put -r backup_${TIMESTAMP} $BACKUP_DIR/
          quit
          SFTP_EOF

          echo "‚úÖ Backup created: backup_${TIMESTAMP}"
          EOF

          # Create cleanup script
          cat > cleanup_backups.sh << 'EOF'
          #!/bin/bash
          set -e

          SFTP_HOST="$1"
          SFTP_USER="$2"
          BACKUP_DIR="$3"
          MAX_BACKUPS="$4"

          echo "üßπ Managing backup retention..."

          # Get list of backups and clean up old ones
          sftp -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null "$SFTP_USER@$SFTP_HOST" << SFTP_EOF
          cd $BACKUP_DIR
          ls -la
          quit
          SFTP_EOF

          # Note: More sophisticated cleanup would require parsing ls output
          # For now, we'll rely on manual cleanup or server-side scripts
          echo "‚ÑπÔ∏è Backup cleanup completed"
          EOF

          # Create deployment script
          cat > deploy.sh << 'EOF'
          #!/bin/bash
          set -e

          SFTP_HOST="$1"
          SFTP_USER="$2"
          REMOTE_DIR="$3"
          LOCAL_DIR="$4"

          echo "üöÄ Deploying to production..."

          # Use rsync over SSH for efficient deployment
          rsync -avz --delete \
            -e "ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null" \
            --exclude='.git' \
            --exclude='node_modules' \
            --exclude='wp' \
            --exclude='.well-known' \
            "$LOCAL_DIR/" "$SFTP_USER@$SFTP_HOST:$REMOTE_DIR/"

          echo "‚úÖ Deployment completed successfully"
          EOF

          chmod +x *.sh

      - name: Setup SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa

          # Add host to known_hosts to avoid prompts
          ssh-keyscan -H "${{ secrets.FTP_SERVER }}" >> ~/.ssh/known_hosts 2>/dev/null || true

      - name: Create backup
        env:
          SFTP_HOST: ${{ secrets.FTP_SERVER }}
          SFTP_USER: ${{ secrets.FTP_USERNAME }}
          REMOTE_DIR: ${{ secrets.FTP_PUBLIC_DIR }}
          BACKUP_DIR: ${{ secrets.FTP_BACKUP_DIR }}
          TIMESTAMP: ${{ needs.build.outputs.timestamp }}
        run: |
          ./backup_manager.sh "$SFTP_HOST" "$SFTP_USER" "$REMOTE_DIR" "$BACKUP_DIR" "$TIMESTAMP" "${{ env.MAX_BACKUPS }}" || {
            echo "‚ö†Ô∏è Backup creation failed, but continuing with deployment"
          }

      - name: Deploy to production
        env:
          SFTP_HOST: ${{ secrets.FTP_SERVER }}
          SFTP_USER: ${{ secrets.FTP_USERNAME }}
          REMOTE_DIR: ${{ secrets.FTP_PUBLIC_DIR }}
        run: |
          ./deploy.sh "$SFTP_HOST" "$SFTP_USER" "$REMOTE_DIR" "dist"

      - name: Verify deployment
        env:
          DEPLOYMENT_URL: ${{ secrets.DEPLOYMENT_URL }}
        run: |
          if [ -n "${DEPLOYMENT_URL:-}" ]; then
            echo "üîç Verifying deployment at $DEPLOYMENT_URL"
            
            # Wait a moment for deployment to propagate
            sleep 10
            
            # Check with retries
            for i in {1..5}; do
              if curl -f -s -o /dev/null -w "%{http_code}" "$DEPLOYMENT_URL" | grep -q "200"; then
                echo "‚úÖ Deployment verification successful (attempt $i)"
                exit 0
              else
                echo "‚è≥ Verification attempt $i failed, retrying in 10s..."
                sleep 10
              fi
            done
            
            echo "‚ùå Deployment verification failed after 5 attempts"
            exit 1
          else
            echo "‚ÑπÔ∏è No DEPLOYMENT_URL configured, skipping verification"
          fi

      - name: Rollback on failure
        if: failure()
        env:
          SFTP_HOST: ${{ secrets.FTP_SERVER }}
          SFTP_USER: ${{ secrets.FTP_USERNAME }}
          REMOTE_DIR: ${{ secrets.FTP_PUBLIC_DIR }}
          BACKUP_DIR: ${{ secrets.FTP_BACKUP_DIR }}
          TIMESTAMP: ${{ needs.build.outputs.timestamp }}
        run: |
          echo "‚ùå Deployment failed, attempting rollback..."

          # Get the most recent backup (excluding the one we just created)
          LATEST_BACKUP=$(sftp -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null "$SFTP_USER@$SFTP_HOST" << SFTP_EOF | grep "backup_" | grep -v "$TIMESTAMP" | sort | tail -n1 | awk '{print $9}'
          cd $BACKUP_DIR
          ls -1 backup_*
          quit
          SFTP_EOF
          )

          if [ -n "$LATEST_BACKUP" ]; then
            echo "üì¶ Rolling back to: $LATEST_BACKUP"
            
            sftp -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null "$SFTP_USER@$SFTP_HOST" << SFTP_EOF
            get -r $BACKUP_DIR/$LATEST_BACKUP/* $REMOTE_DIR/
            quit
          SFTP_EOF
            
            echo "‚úÖ Rollback completed"
          else
            echo "‚ùå No backup found for rollback"
            exit 1
          fi

      - name: Cleanup old artifacts
        if: success()
        run: |
          echo "üßπ Cleaning up GitHub artifacts..."
          # The artifact will be automatically cleaned up based on retention-days setting

  notify:
    runs-on: ubuntu-latest
    needs: [build, deploy]
    if: always()
    steps:
      - name: Notify deployment status
        run: |
          if [ "${{ needs.deploy.result }}" = "success" ]; then
            MESSAGE="üéâ ${{ needs.build.outputs.deployment-message }} - SUCCESS"
            COLOR="good"
          else
            MESSAGE="üí• Deployment failed - check logs for details"
            COLOR="danger"
          fi

          echo "$MESSAGE"
